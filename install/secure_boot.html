<!DOCTYPE html>
<html lang="pt-BR" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="description" content="Aprendendo sobre Secure Boot e TPM e como usar essas tecnologias no Linux.">
    <meta name="keywords" content="formata√ß√£o, windows, linux, freebsd, bios, uefi, instala√ß√£o, balena, etcher, ventoy, os">
    <meta name="author" content="Cain">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Boot & TPM</title>
    <!--Social Media Open Graph-->
    <meta property="og:title" content="Instala√ß√£o de Sistemas Operacionais - Secure Boot"/>
    <meta property="og:url" content="https://cain-dev.github.io/default/"/>
    <meta property="og:type" content="article"/>
    <meta property="og:description" content="Aprendendo sobre Secure Boot e TPM e como usar essas tecnologias no Linux."/>
    <meta property="og:image" content="https://raw.githubusercontent.com/cain-dev/default/main/assets/images/ogimage.jpg"/>
    <!--/Social Media Open Graph-->
    <!--Links-->
    <link rel="shortcut icon" href="https://uefi.org//themes/custom/uefi_d10_olivero/favicon.ico">
    <link rel="stylesheet" type="text/css"href="../os_style.css">   
    <!--/Links-->
</head>
<body>
    <header id="main-header">
        <ul>
            <li><a href="../index.html">Home</a></li>
            <li><p>@cain-dev</p></li>
            <li><a href="../extra/contact.html">Contato</a></li>
        </ul>
    </header>
    <main id="main-area">
        <h1>Secure Boot</h1>
        <!-- INTRODU√á√ÉO -->
        <!-- ///////////////////////////////////////////////////////////////////////////////////////////////-->
        <h2>Introdu√ß√£o</h2>
        <p>Embora eu desconfio bastante dos motivos da Microsoft passar a exigir Secure Boot e TPM2.0 para utiliza√ß√£o do Windows 11, e desconfiar mais ainda de como os fabricantes implementaram essas tecnologias, a verdade √© que as tecnologias em si s√£o bem interessantes e podem garantir a prote√ß√£o para muita dor de cabe√ßa dependendo do seu caso.</p>
        <p>O problema √© que em todo lugar que voc√™ buscar, tanto o Secure Boot quanto o TPM2.0 s√£o descritos apenas como nada mais que "requisitos do Windows 11", e a verdade √© que eles s√£o muito mais que isso, assim como tamb√©m o discurso de "basta atualizar a sua BIOS e manter o Windows 11 atualizado com o Secure Boot ativo" n√£o vale de nada, e se a minha placa m√£e j√° n√£o tem mais suporte? E se eu n√£o utilizar Windows 11? E se essas chaves "originais" forem prejudiciais (sim isso existe, explico mais adiante)? </p>
        <p>A verdade √© que quando voc√™ entende essas tecnologias, esse uso "est√°tico", √© de longe o pior caso! A verdade √© que as chaves usadas no Secure Boot podem ser modificadas, anexadas a outras chaves, removidas, voc√™ mesmo pode at√© criar as suas chaves! E o mesmo serve para o m√≥dulo TPM, voc√™ pode gerar nele as chaves para usar em diversas atividades fora da inicializa√ß√£o do sistema e uma simples trava de disco, eu vou at√© al√©m: Se voc√™ tem um computador mais antigo e n√£o utiliza Windows as chaces s√£o que voc√™ pode se beneficiar de Secure Boot e seu m√≥dulo TPM muito mais do que quem tem computador novo! A menos que queira usar Windows 11...</p>
        <!-- O QUE √â SECURE BOOT -->
        <!-- ///////////////////////////////////////////////////////////////////////////////////////////////-->
        <h2>Ent√£o o que √© Secure Boot?</h2>
        <p>Bom, o Secure Boot pode ser entendido como uma checagem de seguran√ßa pr√©-boot, basicamente, um mecanismo que garante que nenhum execut√°vel seja carregado sem que seja previamente autenticado pelo fabricante do equipamento e/ou o usu√°rio do equipamento e que al√©m disso n√£o esteja listado em nenhuma <i>blacklist</i>, se e somente se o software obedece essas condi√ß√µes ele ser√° inicializado. A genialidade disso √© que mesmo que voc√™ seja infectado com algum c√≥digo muito cabuloso de <i>early-loading</i>, ele simplesmente n√£o ter√° condi√ß√µes de ser carregado. o Secure Boot sozinho (se devidamente configurado) √© mais do que suficiente para impedir a esmagadora maioria dos ransomwares.</p>
        <!-- O QUE √â TPM -->
        <!-- ///////////////////////////////////////////////////////////////////////////////////////////////-->
        <h2>E o que √© TPM?</h2>
        <p>Para entender o que √© o maldito do TPM primeiro voc√™ precisa entender o que √© Trusted Computing, a Trusted Computing Group √© uma organiza√ß√£o sem fins lucrativos (aham, duvido...) que estabelesce padr√µes de hardware e software para a tal "computa√ß√£o confi√°vel", entenda isso como "como garantir que o computador confie nele mesmo e n√£o em voc√™" (acho que deu pra come√ßar e entender a raz√£o da galera do software livre ser p√© atr√°s com esse tipo de coisa...). TPM, nada mais √© que um m√≥dulo que voc√™ tem na sua placa m√£e (ou que voc√™ adiciona na sua placa m√£e) para usar fun√ß√µes de computa√ß√£o confi√°vel, como por exemplo, a cria√ß√£o e ger√™ncia de chaves de dentro do m√≥dulo, sem a exposi√ß√£o dessas chaves para nenhum outro ambiente. Ou seja: Qualquer que seja a autentica√ß√£o que voc√™ deseja utilizar, a chave ser√° gerada DENTRO do m√≥dulo TPM e ficar√° l√°, e s√≥ vai ser utilizado no processo da autentica√ß√£o.</p>
        <p>Sendo assim, n√£o √© poss√≠vel nem utilizar um keylogger para roubar as chaves para desencriptar algo! A desvantagem √© que isso transforma os ambientes de sistema em ambientes completamente ef√™meros, pois se este m√≥dulo for comprometido de alguma forma, sej√° l√° o que dependa desse m√≥dulo vai ficar sem autentica√ß√£o.</p>
        <p>Ent√£o TPM nada mais √© do que a sigla para <i>Trusted Platform Module</i>, hoje em dia a maioria das placas-m√£e j√° vem com um m√≥dulo desse desde o firmware (tamb√©m chamado de fTPM), e tamb√©m √© importante lembrar que placas-m√£e mais antigas (pr√© intel 99, placas m√£e DDR3) podem ter o m√≥dulo TPM 1.2 adicionado, n√£o √© o mesmo que exigido para o Windows 11 mas ainda assim √© uma op√ß√£o interessante para quem quer fazer uso desse tipo de seguran√ßa.</p>
        <!-- O QUE √â fTPM -->
        <!-- ///////////////////////////////////////////////////////////////////////////////////////////////-->
        <h3>Adendo sobre fTPM</h3>
        <p>√â muito importante dizer, que embora o fTPM seja suficiente para garantir algum funcionamento em quest√µes de compatibilidade, ele <strong>n√£o √© a mesma coisa que um m√≥dulo TPM dedicado!</strong> O m√≥dulo fTPM que tem na sua placa m√£e mais nova, est√° a√≠ usando recursos e contexto multifun√ß√£o, por uma quest√£o de compatibilidade com o Windows 11, o m√≥dulo TPM √© um chip isolado, acrecentado a uma placa, com um <i>header</i> para uma comunica√ß√£o espec√≠fica com a plataforma.</p>
        <p>como o pr√≥prio site da <i>Dell</i> indica: <i>"Um TPM discreto tem controle total sobre os recursos internos dedicados (como mem√≥ria vol√°til, mem√≥ria n√£o vol√°til e l√≥gica criptogr√°fica), e √© a √∫nica fun√ß√£o que acessa e utiliza esses recursos. Um TPM baseado em firmware n√£o tem seu pr√≥prio armazenamento dedicado. Ele conta com os servi√ßos do sistema operacional e da plataforma para obter acesso ao armazenamento dentro da plataforma."</i></p>
        <!-- CONTRAS -->
        <!-- ///////////////////////////////////////////////////////////////////////////////////////////////-->
        <h2>Ent√£o se √© t√£o bom assim, n√£o deveriamos usar?</h2>
        <p>Ehhrr... A√≠ que t√°... O conceito da tecnologia em si √© muito bom, por√©m a implementa√ß√£o pode ser BEM porca, e √© bom lembrar que a seguran√ßa para uma plataforma √© t√£o boa quanto a sua implementa√ß√£o, n√£o s√≥ existem casos de chaves de autentica√ß√£o que foram vazadas por fabricantes de componentes, como chaves de teste que foram validadas pelo firmware do aparelho em p√≥s produ√ß√£o para usu√°rio final e at√© mesmo a mera data de expira√ß√£o dessas chaves. O m√≥dulo TPM por si s√≥ √© uma caixa preta que funciona com tipos muito espec√≠ficos de algoritmos e n√£o trabalha s√≥ como um gerador + mem√≥ria, na data que estou escrevendo isso temos os m√≥dulos 1.2 e 2.0, o padr√£o para o m√≥dulo 1.2 tende a rsa2048/sha1 e o famigerado 2.0 rsa2048/sha256... Por mais que o 2.0 permite o uso de curva el√≠ptica mas... N√£o √© o que voc√™ vai achar por a√≠.</p>
        <p>Sem contar que a grande maioria dos fabricantes simplesmente enfiam assinaturas Microsoft goela abaixo, algumas vezes at√© chaves sabidamente explor√°veis, e manuten√ß√£o que √© bom nada, em alguns casos (como nas plataformas ARM) voc√™ pode ser simplesmente impedido de carregar outro sistema ou mesmo <i>brickar</i> o seu dispositivo caso tente mudar as chaves! Ent√£o sim, por mais que √© uma tecnologia que tem bastante potencial elas funcionaram basicamente como um cavalo de tr√≥ia para o usu√°rio final.</p>
        <p>Por√©m, em certas circust√¢ncias, voc√™ pode atualizar a <i>blacklist</i> manualmente, fazendo com que chaves sabidamente exploradas n√£o sejam carregadas, mesmo que a sua placa m√£e j√° n√£o tenha mais atualiza√ß√µes de firmware, voc√™ pode criar as suas chaves, com ou sem o uso de um m√≥dulo TPM, e voc√™ pode at√© mesmo remover todas as chaves usadas nesse processo e usar SOMENTE as SUAS chaves! E √© a√≠ que essa tecnologia brilha, longe de padroniza√ß√£o de fabricantes, longe de implementa√ß√µes est√°ticas, especialmente uso para quem tem computadores mais antigos.</p>
        <!-- MODOS DE OPERA√á√ÉO -->
        <!-- ///////////////////////////////////////////////////////////////////////////////////////////////-->
        <h2>User mode? Windows mode?</h2>
        <p>√â, eu sei que isso √© confuso mas s√£o coisas diferentes, por√©m √© bem f√°cil de entender a partir do momento que voc√™ consegue separar as coisas. Para o Secure Boot ser implementado para para os par√¢metros do Windows, ele precisa seguir a especifica√ß√£o da Microsoft, ent√£o a sua placa m√£e vai possibilitar dois tipos de "m√©todos" para usar o Secure Boot: O modo "<em>Windows</em>", que segue as especifica√ß√µes da Microsoft, e o modo "<em>OtherOS/Custom</em>", que te da a liberdade de configurar conforme a sua vontade... Ao menos <em>deveria</em> ser assim, mas o que efetivamente ocorre com a esmagadora maioria das implementa√ß√µes √© que o modo "Windows" ativa a checagem de Secure Boot e o modo "OtherOS" ignora a checagem de Secure Boot...</p>
        <p>Independente do modo que escolha, seja <em>Windows</em>, seja <em>OtherOS/Custom</em>, a placa m√£e que suporta Secure Boot vai trabalhar com a inicializa√ß√£o baseado em 2 "correntes" de inicializa√ß√£o: O modo <em>Setup mode</em>, ou seja, o modo pr√©-configura√ß√£o, e o <em>User mode</em>, ou seja, o modo p√≥s-configura√ß√£o, quando o Secure boot est√° devidamente habilitado.</p>
        <p>Resumo:</p>
        <ul>
            <li><p>Windows Mode = Checagem de Secure Boot Ativada;</p></li>
            <li><p>OtherOS Mode = Checagem de Secure Boot Desativada;</p></li>
            <li><p>Setup Mode = As chaves n√£o foram configuradas, o Secure Boot n√£o est√° em funcionamento;</p></li>
            <li><p>User Mode = As chaves foram configuradas, o Secure Boot est√° em funcionamento.</p></li>
        </ul>
        <p>Bem contraintuitivo, eu sei... Essa √© s√≥ uma das diversas controv√©rsias do Secure Boot...</p>
        <h2>Controv√©rsias? Quais controv√©rsias?</h2>
        <p>T√°... Vamos come√ßar pelo b√°sico... Secure Boot √© um termo muito mais comercial do que um termo t√©cnico, o que ele faz √© nada mais nada menos do que uma verifica√ß√£o pr√©-boot, ele n√£o √© a √∫nica ferramenta de verifica√ß√£o pr√©-boot e eu duvido muito que em algum momento ele seja categorizado como a "melhor"... Eu creio que o funcionamento de verifica√ß√£o do Android em dispositivos m√≥veis √© muito mais interessante do que isso.</p>
        <p>Parte do problema est√° n√£o s√≥ no que o Secure Boot √©, mas tamb√©m no que ele <strong>n√£o √©!</strong> Ao ver na BIOS uma op√ß√£o como "Deseja ativar o boot seguro?" Parece que √© uma op√ß√£o que voc√™ ativa e vai ganhar mais "1000 pontos de seguran√ßa", e nada poderia estar mais longe da verdade.</p>
        <p>O Secure Boot, em muitos casos √© desnecess√°rio, redundante, pode ser incoveniente, muitas vezes in√∫til e em alguns casos at√© mesmo <strong>prejudicial</strong> Sim, voc√™ n√£o leu isso errado, mas vamos por partes...</p>
        <p>Quando falamos em Secure Boot, falamos em UEFI, quando falamos em UEFI estamos falando largamente em X86, entendido at√© a√≠? √ìtimo. Ent√£o voc√™ vai instalar o Linux Mint no seu computador, voc√™ baixou a iso e verificou o <em>MD5</em> dessa iso, voc√™ instalou o sistema e usou o sistema apenas com pacotes assinados pela distribui√ß√£o, parab√©ns, voc√™ acabou de fazer o mesmo trabalho que o Secure Boot ia fazer na sua m√°quina... √â s√©rio... </p>
        <p>Parece idiota quando se coloca nesses termos mas √© exatamente a mesma coisa, se voc√™ verificou algo pr√©-boot, voc√™ tem o mesmo benef√≠cio que o Secure Boot pode te proporcionar. As chaves nesses pacotes podem ser t√£o comprometidas quanto as chaves certificadas, na verdade as verifica√ß√µes nos pacotes tendem a ser mais din√¢micas e √∫teis do que aquelas contidas na sua placa m√£e. Esse termo, <i>Secure Boot</i>, passa a impress√£o de que as coisas est√£o MAIS seguras, quando em muitos casos (como esse que acabei de citar), basicamente n√£o h√° ganhos.</p>
        <p>Eu recomendo fortemente que voc√™ leia <a class="link" href="https://github.com/pbatard/rufus/wiki/FAQ#user-content-Why_do_I_need_to_disable_Secure_Boot_to_use_UEFINTFS">aqui</a> o FAQ do conhecid√≠ssimo Rufus, uma das sen√£o a ferramenta mais utilizada para prepara√ß√£o de dispositivos <i>boot√°veis</i>, e como √© dito a√≠ um nome mais preciso para Secure Boot poderia ser  "Imposi√ß√£o da Assinatura do Bootloader", pois √© isso que ele efetivamente faz... No melhor dos casos...</p>
        <p>E voc√™ me pergunta: "Como assim no melhor dos casos?", e eu te respondo de maneira muito f√°cil, imposi√ß√£o de assinaturas n√£o necessariamente, repito: <mark>N√£o necessariamente!</mark> Vai ter influ√™ncia sobre o estado de seguran√ßa da sua plataforma. N√£o ativar o Secure Boot <strong>N√£o significa de forma alguma deixar o seu computador em um estado inseguro!</strong> E isso precisa ser dito.</p>
        <p>A grande verdade √© que a impress√£o comum √© que os motivos dessa imposi√ß√£o feita pela Microsoft aos fabricantes para a padroniza√ß√£o para seus sistemas est√° longe de ser por uma quest√£o de seguran√ßa e muito mais por quest√µes abusivas, quem efetivamente trouxe essa tecnologia foi ela, em meados de lan√ßamento do Windows 8 (salvo engano), e obviamente causou muitas dores de cabe√ßa para quem tentava instalar outros sistemas e at√© mesmo quem tentava reinstalar o Windows nessas m√°quinas. Esse per√≠odo de transi√ß√£o teve uma implementa√ß√£o muito porca, em alguns casos com t√©cnicos pedindo aos fabricantes que "pelo amor de Deus me d√° uma atualiza√ß√£o de BIOS que me permite voltar pro Windows 7".</p>
        <p>Ah, a raz√£o pela qual eu falei que voc√™ tem mais seguran√ßa usando o Secure Boot longe do Windows? √â simples: Windows √© um sistema ub√≠quo quando o assunto √© usu√°rio final comum, por isso os fabricantes tendem a assinar seus produtos com as chaves para esses usu√°rios finais comuns... Se todo mundo, usa as mesmas chaves para validar tudo, logo, se essa entidade certificadora √© comprometida ent√£o a seguran√ßa do Secure Boot tamb√©m √©!</p>
        <p>N√£o meu caro, voc√™ n√£o leu errado: Se 1 - O Secure Boot s√≥ permite iniciar o que cont√©m as chaves reconhecidas e 2 - As chaves da Microsoft sempre s√£o reconhecidas e est√£o em todo lugar, logo 3 - O Secure Boot permite tudo! Ent√£o, se voc√™ conseguir usar o Secure Boot sem as chaves da Microsoft, voc√™ vai ter mais seguran√ßa pelo Secure Boot no Linux que no Windows! Inclusive podendo (como na parte inferior deste guia) voc√™ mesmo assinar o loader do Windows para que inicie sem as chaves Microsoft.</p>
        <p>O problema √© que s√£o grandes as chances que dispositivos na sua m√°quina parem de funcionar, e, dependendo do dispositivo, que o seu computador entre em <i>soft brick</i> ou mesmo <i>hard brick</i>! √â s√©rio! O secure boot n√£o trabalha com "meia autentica√ß√£o", ou todas as chaves s√£o conhecidas e seu sistema vai iniciar, ou alguma chave n√£o √© conhecida e ou n√£o vai iniciar ou pelo menos n√£o vai iniciar o seu dispositivo... Boa sorte se a sua placa de v√≠deo depender de uma chave comprometida...</p>
        <p>Em resumo:</p>
        <ul>
            <li><p>Secure Boot √© antes de mais nada um termo comercial;</p></li>
            <li><p>Ele n√£o necessariamente influencia na seguran√ßa;</p></li>
            <li><p>A impress√£o que passa √© de que os motivos para a Microsoft impor o seu uso n√£o tem nada haver com seguran√ßa;</p></li>
            <li><p>O Secure Boot falhou absurdamente em entregar o prometido;</p></li>
            <li><p>Na esmagadora maioria das vezes, a implementa√ß√£o mais comum dele o torna quase in√∫til;</p></li>
            <li><p>O seu uso pode ser prejudicial, inclusive podendo <i>brickar</i> plataformas.</p></li>
        </ul>
        <p>S√≥ pra fechar esse cap√≠tulo com chave de diamante... Parte dos requisitos de assinatura √© a... Acredite se quiser... <strong>N√£o utiliza√ß√£o de c√≥digo GPLv3!</strong> Voc√™ n√£o leu isso errado, ao mesmo tempo em que existe o Shim para fazer o intercessor entre as chaves Microsoft e o loader do Linux, c√≥digos em GPLv3 n√£o est√£o dentro do escopo para serem assinados... Se isso n√£o √© persegui√ß√£o e abuso eu n√£o sei o que √©.</p>
        <!-- PREPARANDO O SISTEMA -->
        <!-- ///////////////////////////////////////////////////////////////////////////////////////////////-->
        <h2>E se eu quiser usar isso? Por onde come√ßo?</h2>
        <p>Bom, a minha primeira recomenda√ß√£o √© que voc√™ <mark>salve as configura√ß√µes da sua BIOS!</mark>, a maioria esquece disso e depois vai perder bem um tempo configurando tudo novamente. A segunda coisa a se fazer √© <mark>voltar para as configura√ß√µes de f√°brica da placa m√£e</mark> e, se poss√≠vel <mark>apagar todas as chaves do secure boot</mark> atrav√©s da pr√≥pria placa m√£e. A terceira coisa a se fazer √© (se poss√≠vel) <mark>regravar a √∫ltima vers√£o da bios da sua placa m√£e</mark>, e caso voc√™ tenha comprado um m√≥dulo TPM, <mark>conectar este m√≥dulo na sua placa m√£e</mark>. Por fim <mark>retorne a sua placa m√£e para as configura√ß√µes de f√°brica mais uma vez</mark> e <mark>carregue as chaves padr√£o da sua placa m√£e</mark>, por√©m, sem ativar o modo Windows! (ou seja, sem efetivamente ativar o secure boot).</p>
        <p>Apesar da dor de cabe√ßa, tudo isso vai garantir que voc√™ tenha um ambiente limpo e com chaves v√°lidas (ou t√£o v√°lidas quanto poss√≠vel).</p>
        <h3>Fazendo backup das chaves</h3>
        <p>Ent√£o voc√™ subiu o seu sistema operacional, com as chaves carregadas por√©m sem o secure boot ativo, a primeira coisa a se fazer √© o backup de cada uma dessas chaves usando a ferramenta <em>efi-readvar</em> do pacote <em>efitools</em>.</p>
        <p>Vamos criar os diret√≥rios para come√ßar os trabalhos com o comando:</p>
        <code>mkdir -vp keys/{auth,backup,cfg,esl,ms,oem}</code>
        <p>E agora vamos aos backups das chaves do seu sistema...</p>
        <code>for var in PK KEK db dbx ; do efi-readvar -v $var -o keys/backup/old_${var}.esl; done</code>
        <p>Caso queira fazer manualmente:</p>
        <code>efi-readvar -v PK  -o keys/backup/old_PK.esl</code>
        <code>efi-readvar -v KEK -o keys/backup/old_KEK.esl</code>
        <code>efi-readvar -v db  -o keys/backup/old_db.esl</code>
        <code>efi-readvar -v dbx -o keys/backup/old_dbx.esl</code>
        <p>Uma vez que voc√™ tem o arquivo de backup dessas chaves, eu recomendo que voc√™ acesse o setup com o comando:</p>
        <code>systemctl reboot --firmware-setup</code>
        <p>E de l√° voc√™ <mark>mais uma vez apague todas as chaves!</mark> N√£o tem como fazer um tutorial para todos os casos, voc√™ vai ter que pegar o manual da sua placa-m√£e e realizar essa tarefa conforme o seu caso espec√≠fico. Assim que o sistema iniciar voc√™ pode verificar se o Secure Boot foi desabilitado com o comando abaixo:</p>
        <code>sudo bootctl status 2>&1 | grep 'Secure Boot'<br>Secure Boot: disabled (setup)</code>
        <!-- M√âTODO SBCTL COM MICROSOFT KEYS -->
        <!-- ///////////////////////////////////////////////////////////////////////////////////////////////-->
        <h2>Eu n√£o tenho paci√™ncia pra isso... S√≥ quero ativar o Secure Boot pra jogar o meu "Vav√°"</h2>
        <section class="alert">
            <p>‚ö†Ô∏è <strong>Alerta!</strong> ‚ö†Ô∏è</p>
            <p>Tenha em mente que em alguns sistemas a utiliza√ß√£o desse m√©todo pode ativar um gatilho autom√°tico para assinatura de kernel! A minha recomenda√ß√£o √© que se voc√™ vai usar esse m√©todo use APENAS ele!</p>
        </section>
        <p>Ok, pro teu caso existe uma ferramenta muito boa chamada <em>sbctl</em>, que automatiza todo o processo de carregamento das chaves, basta usar o comando abaixo para gerar as chaves (que se voc√™ tiver usando algo Arch-based ficar√£o no diret√≥rio <mark>/var/lib/sbctl/keys/</mark>):</p>
        <code>sbctl create-keys</code>
        <p>Depois o comando abaixo para carregar as chaves (junto com as chaves Microsoft):</p>
        <code>sbctl enroll-keys -m</code>
        <details class="spoiler" >
            <summary>Carregar as chaves sem as assinaturas da Microsoft (Clique para ver)</summary>
            <p><strong>Alerta:</strong> Isso pode <i>brickar</i> o seu dispositivo! S√≥ use esse comando se voc√™ tiver certeza do que est√° fazendo!</p>
            <code>sbctl enroll-keys</code>
            <p>B√¥nus!</p>
            <p>Se voc√™ (for muito do ignorante) estiver usando dual-boot com Windows, voc√™ pode assinar o pr√≥prio bootloader do Windows (<em>bootmgfw.efi</em>) para que o Windows inicie EM secure boot SEM as chaves Microsoft... Isso √© do caralho!  </p>
        </details>
        <p>Agora basta assinar seu bootloader e/ou kernel e/ou unified kernel image ou seja l√° que diabos voc√™ use pra subir o seu sistema üòÇ basta seguir o exemplo abaixo:</p>
        <code>sbctl sign -s /boot/vmlinuz-linux</code>
        <code>sbctl sign -s /boot/EFI/BOOT/BOOTX64.EFI</code>
        <!--
        <code>sbctl sign -s -o /boot/vmlinuz-linux.signed /boot/vmlinuz-linux</code>
        <code>sbctl sign -s -o /boot/EFI/BOOT/BOOTX64.EFI.signed /boot/EFI/BOOT/BOOTX64.EFI</code>
        -->
        <p>Depois reiniciar o seu computador, acessar o setup da placa-m√£e, colocar o Secure Boot em modo <mark>Windows</mark> e ser feliz jogando o seu "Vav√°". Ah, e caso queira verificar a validade do Secure Boot voc√™ pode utilizar o comando:</p>
        <code>sbctl status</code>
        <p>E vai o resultado vai ser mais ou menos assim:</p>
<pre><code>Installed: ‚úì sbctl is installed
Owner GUID:	xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
Setup Mode: ‚úì Disabled
Secure Boot: ‚úì Enabled
Vendor Keys: microsoft
</code></pre>
        <!-- M√âTODO AVAN√áADO -->
        <!-- ///////////////////////////////////////////////////////////////////////////////////////////////-->
        <h2>Eu n√£o confio em Microsoft nem fabricante, eu n√£o quero carregar nada que eu n√£o assino, eu quero fazer as minhas chaves!</h2>
        <p>Primeiro: Voc√™ √© dos meus! N√≥s precisamos de mais pessoas assim na computa√ß√£o! Mas pro seu caso... Precisamos antes entender o que diabos s√£o cada uma dessas chaves...</p>
        <h3>PK</h3>
        <p>Basicamente a "<i>masterkey</i>" do processo de Secure Boot, basicamente a chave de autoridade m√°xima da plataforma: Essa chave que autoriza toda e qualquer modifica√ß√£o nas chaves subsequentes. √â como se essa chave fosse o <i>handshake</i> entre o propriet√°rio da plataforma e o firmware da plataforma.</p>
        <h3>noPK</h3>
        <p>N√£o √© oficialmente um tipo de chave, algumas vezes chamada de <i>reset key</i>, nada mais √© do que um arquivo vazio assinado com a <em>Platform Key (PK)</em>, que por ser um arquivo devidamente assinado, quando carregado ele efetivamente apaga o conte√∫do da <em>PK</em>, desativando assim o Secure Boot. √â um recurso bastante engenhoso.</p>
        <h3>KEK (Key Exchange Key)</h3>
        <p>Se a PK Key atua como o <i>handshake</i> entre o propriet√°rio da plataforma e o firmware da plataforma, essa chave atua como o <i>handshake</i> entre o firmware e o sistema operacional. Se a chave PK √© a <i>masterkey</i>, a chave KEK √© como uma simples chave de acesso que valida as altera√ß√µes do sistema para o firmware (como nas chaves <em>DB/DBX</em>) sem comprometer a autoridade maior naquela plataforma.</p>
        <h3>DB (Signature Database)</h3>
        <p>Em resumo, essa chave cont√©m as assinaturas dos softwares <em>confi√°veis</em>.</p>
        <h3>DBX (Revoked Signature Database)</h3>
        <p>Em resumo, essa chave cont√©m as assinaturas dos softwares <em>n√£o</em>-confi√°veis. √â interessante ressaltar que o <em>uefi.org</em> mant√©m um bin√°rio com uma lista p√∫blica de chaves revogadas, voc√™ pode acessar essa lista atrav√©s <a class="link" href="https://uefi.org/revocationlistfile">desse link</a>.</p>
        <p>E quanto a hierarquia de autentica√ß√£o √© simples: As chaves PK (ou seja, a masterkey, que s√£o √∫nicas) assinam os certificados PK, noPK e KEK. As chaves KEK (que podem ser mais de uma) por sua vez assinam o DB e o DBX, por fim o DB assina os execut√°veis confi√°veis.</p>
        <h3>E quanto a MOK Key?</h3>
        <p>Ehhrr... Ent√£o... Lembra das cr√≠ticas ao Secure Boot a√≠ acima? A MOK Key n√£o existe como parte da especifica√ß√£o do Secure Boot. Eu explico...</p>
        <p>Devido a quest√£o falada sobre a ubiquidade do Windows e da quantidade de coisas que se escoram nessas assinaturas, foi criado um mini-bootloader de primeiro est√°gio chamado Shim (que vou me segurar muito pra n√£o chamar de gambiarra...), que √© assinado com uma dessas chaves e permite ao usu√°rio criar as suas <em>Machine Owner Keys</em> (ou <em>MOK Keys</em>), e ent√£o o usu√°rio pode criar as suas chaves, assinar os seus execut√°veis e inserir essas chaves "dentro do Shim" para que ele fa√ßa o <i>handshake</i> para possibilitar a inicializa√ß√£o dos seus (usu√°riof) execut√°veis...</p>
        <p>Se voc√™ for no site do Debiam, por exemplo, vai encontrar um <i>disclaimer</i> sobre como o <i>"Secure Boot n√£o √© uma tentativa de obstruir o mercado"</i>, que <i>"A Microsoft age como intermedi√°ria para certificar as organiza√ß√µes autorizadas"</i> e sobre como <i>"os usu√°rios podem inserir as suas chaves, e alguns usu√°rios podem at√© mesmo for√ßar o firmware a reconhecer apenas chaves de usu√°rio"</i>... O ponto √©: Eu entendo a Microsoft, como parte da ponta de lan√ßa do projeto, ter participa√ß√£o na padroniza√ß√£o dessa tecnologia. Eu entendo Microsoft ser uma das autoridades que podem emitir esse tipo de certificado... Mas n√£o estamos falando de chaves da Canonical, Debian e Red Hat j√° presentes na placa m√£e e mecanismos de adi√ß√£o de chaves de usu√°rio diretamente desde o firmware, estamos falando de um bootloader criado como vetor para lidar com as chaves do usu√°rio de dentro de um sistema Linux!</p>
        <p>Eu entendo a Asus ter a chave <em>Platform Key</em> em suas placas m√£e, e j√° ter nos bancos de dado chaves permissivas para Red Hat, Canonical ou Debian e at√© mesmo da Microsoft... Mas a necessidade de um bootloader assinado pela Microsoft que vai ent√£o carregar as minhas chaves √© um cuspe na minha cara!</p>
        <p>Perceba: Eu n√£o estou dizendo que o Shim n√£o √© uma boa ferramenta, isso ele √©! Eu n√£o estou dizendo que para alguns Setups ele n√£o √© uma boa alternativa, isso ele tamb√©m √©, mas, se a Microsoft tem poder para exigir o reconhecimento das suas assinaturas diretamente nas placas m√£es ela tamb√©m tem poder para colocar ao menos Red Hat, Canonical, Debian e at√© mesmo uma chave para o FreeBSD no mesmo barco, ou n√£o?</p>
        <p>Ent√£o isso √© a MOK key: √â uma chave de usu√°rio, que voc√™ insere numa lista de chaves confi√°veis de um mini-bootloader, para que esse permita as aplica√ß√µes assinadas por voc√™.</p>
        <h3>E quanto aos formatos de arquivo?</h3>
        <ul>
            <li><p><em>.key</em> - <i>PEM (Privacy-Enhanced Mail)</i> - Usado para chaves privadas</p></li>
            <li><p><em>.crt</em> - <i>PEM (Privacy-Enhanced Mail)</i> - Usado para chaves p√∫blicas.</p></li>
            <li><p><em>.cer</em> - <i>DER (Distinguished Encoding Rules)</i> - Usado para chaves p√∫blicas.</p></li>
            <li><p><em>.esl</em> - <i>EFI Signature List</i> - Usedo pelo EFI, uma cole√ß√£o de chaves p√∫blicas e hashes.</p></li>
            <li><p><em>.auth</em> - <i>Signed EFI Signature List</i> - Usedo pelo EFI, √© um formato de esl assinado.</p></li>
        </ul>
        <p>Se voc√™ n√£o entende nada de criptografia basta entender que chaves privadas assinam (no sentido de autenticar a pessoa que √© respons√°vel por aquilo, como num contrato), por isso elas s√£o <em>privadas</em>, chaves p√∫blicas s√£o provas de assinatura (no sentido de verificar o respons√°vel pela assinatura), por isso elas s√£o <em>publicas</em>. PEM √© uma codifica√ß√£o baseada em texto, cont√©m cabe√ßalhos e rodap√©s, mais f√°cil para ser integrada e/ou editada; DER √© uma codifica√ß√£o bin√°ria, mais compacto e eficiente por√©m sem cabe√ßalhos e rodap√©s, mais dif√≠cil para ser integrada e/ou editada; .auth podem ser usados em <em>Setup Mode</em> ou <em>User Mode</em> ESL s√≥ podem ser usados em <em>Setup Mode</em>.</p>
        <h2>Gerando as chaves</h2>
        <section class="alert">
            <p>De come√ßo um alerta... √â quase que imposs√≠vel para mim mostrar aqui toda varia√ß√£o de cria√ß√£o de chave, seja estrita, seja protegida por GPG... Eu recomendo voc√™ utilizar isso como uma base para criar as suas chaves mas n√£o se limite ao que est√° aqui, aqui estou diluindo o m√©todo para que voc√™ entenda o processo.</p>
        </section>
        <!-- M√âTODO AVAN√áADO - GERAR CHAVES MANUALMENTE -->
        <!-- ///////////////////////////////////////////////////////////////////////////////////////////////-->
        <p>Para gerar as chaves use o comandos abaixo:</p>
        <code>for key_type in PK KEK db; do openssl req -new -x509 -newkey rsa:2048 -subj "/CN=Private ${key_type}" -keyout ${key_type}.key -out ${key_type}.crt -days 3650 -sha256 -nodes; done</code>
        <p>Caso queira criar manualmente cada uma delas:</p>
        <code>openssl req -new -x509 -newkey rsa:2048 -subj "/CN=Private PK" -keyout PK.key -out PK.crt -days 3650 -sha256 -nodes</code>          
        <code>openssl req -new -x509 -newkey rsa:2048 -subj "/CN=Private KEK" -keyout KEK.key -out KEK.crt -days 3650 -sha256 -nodes</code>
        <code>openssl req -new -x509 -newkey rsa:2048 -subj "/CN=Private db" -keyout db.key -out db.crt -days 3650 -sha256 -nodes</code>
        <p>Esse comando vai gerar chaves do tipo <em>PEM</em>, por padr√£o se usa <em>rsa:2048</em> com <em>sha256</em> com <em>3650</em> dias (basicamente 10 anos), mas fique a vontade para testar conforme sua necessidade como usar <em>rsa:4096</em> para mais seguran√ßa, remover o argumento <em>-nodes</em> e proteger a chave privada com senha,  ou mesmo usar <em>sha1</em> para especifica√ß√µes mais antigas, de qualquer modo lembre-se de que deve ser compat√≠vel com as especifica√ß√µes da sua plataforma (e s√≥ o manual pode te dizer isso)!</p>
        <p>Caso queira verificar isoladamente as chaves voc√™ pode usar o comando como refer√™ncia:</p>
        <code>openssl x509 -text -noout -inform PEM -in /keys/PK.pem</code>
        <p>(Opcional) Caso queira gerar um arquivo de tipo <em>DER</em> das chaves geradas acima voc√™ pode usar o comando:</p>
        <code>for key_type in PK KEK db; do openssl x509 -outform DER -in ${key_type}.crt -out ${key_type}.cer ; done</code>
        <!-- M√âTODO AVAN√áADO - GERAR CHAVES POR CONFIG FILE -->
        <!-- ///////////////////////////////////////////////////////////////////////////////////////////////-->
        <details class="spoiler" >
            <summary>Usando config files (Clique para exibir)</summary>
            <p>Lembrando tamb√©m que o argumento <em>-subj</em> pode receber mais par√¢metros conforme a sua necessidade, por exemplo:</p>
            <code>... -subj "/C=BR/ST=S√£o Paulo/L=S√£o Paulo/O=Minha Empresa/OU=Departamento de TI/CN=meusite.com/emailAddress=contato@meusite.com/GN=Jo√£o/SN=Silva/UID=joaozinho" ...</code>
            <ul>
                <li><p>C=BR, o par√¢metro <em>Country</em> recebe o identificador de pa√≠s, nesse caso Brasil.</p></li>
                <li><p>ST=S√£o Paulo, o par√¢metro <em>State</em> recebe o identificador de estado ou prov√≠ncia, nesse caso S√£o Paulo.</p></li>
                <li><p>L=S√£o Paulo, o par√¢metro <em>Locality</em> recebe o identificador de cidade ou regi√£o, nesse caso S√£o Paulo.</p></li>
                <li><p>O=Minha Empresa, o par√¢metro <em>Organization</em> recebe o identificador de organiza√ß√£o ou empresa, nesse caso Minha Empresa.</p></li>
                <li><p>OU=Departamento de TI, o par√¢metro <em>Organization Unit</em> recebe o identificador de unidade ou departamento da organiza√ß√£o ou empresa, nesse caso Departamento de TI.</p></li>
                <li><p>CN=meusite.com, o par√¢metro <em>Common name</em> recebe o de nome comum, que pode ser um identificador geral ou de dom√≠nio, nesse caso meusite.com.</p></li>
                <li><p>emailAddress=contato@meusite.com, o par√¢metro <em>emailAddress</em> recebe o endere√ßo de email, nesse caso contato@meusite.com.</p></li>
                <li><p>GN=Jo√£o, o par√¢metro <em>Given name</em> recebe o nome pr√≥prio, nesse caso Jo√£o.</p></li>
                <li><p>SN=Silva, o par√¢metro <em>Surname</em> recebe o sobrenome, nesse caso Silva.</p></li>
                <li><p>UID=joaozinho, o par√¢metro <em>User ID</em> recebe o identificador de usu√°rio, nesse caso joaozinho.</p></li>
            </ul>
            <p>Voc√™ tamb√©m pode gerar essa chave atrav√©s de um config file como no exemplo abaixo:</p>
            <code>nano keys/cfg/PK.cfg</code>
<pre><code>
[ req ]
default_bits         = <em>4096</em>
encrypt_key          = no
string_mask          = utf8only
utf8                 = yes
prompt               = no
distinguished_name   = req_distinguished_name
x509_extensions      = my_x509_exts
    
[ req_distinguished_name ]
countryName             = <em>BR</em>
stateOrProvinceName     = <em>S√£o Paulo</em>
localityName            = <em>S√£o Paulo</em>
organizationName        = <em>Minha Empresa</em>
organizationalUnitName  = <em>Departamento de TI</em>
commonName              = <em>meusite.com Platform Key</em>
emailAddress            = <em>contato@meusite.com</em>
givenName               = <em>Jo√£o</em>
surname                 = <em>Silva</em>
userId                  = <em>joaozinho</em>
<!--
[ req_distinguished_name ]
C                    = BR
ST                   = S√£o Paulo
L                    = S√£o Paulo
O                    = Minha Empresa
OU                   = Departamento de TI
CN                   = meusite.com
emailAddress         = contato@meusite.com
GN                   = Jo√£o
SN                   = Silva
UID                  = joaozinho
-->    
[ my_x509_exts ]
keyUsage             = digitalSignature
extendedKeyUsage     = codeSigning
basicConstraints     = critical,CA:FALSE
subjectKeyIdentifier = hash
</code></pre>
            <p>Lembre-se de n√£o usar <em>-subj</em> quando for fazer a chave atrav√©s de um arquivo de configura√ß√£o, pois qualquer par√¢metro passado para esse argumento vai sobreescrever os par√¢metros dados pelo arquivo.</p>
            <code>openssl req -x509 -sha256 -days 3650 -outform PEM -config keys/cfg/PK.cfg -keyout keys/PK.key -out keys/PK.crt</code>
            <p>Voc√™ pode verificar a chave com:</p>
            <code>openssl x509 -text -noout -inform PEM -in keys/PK.crt</code>
            <p>Agora vamos copiar este arquivo como KEK.cfg:</p>
            <code>cp -v keys/cfg/{PK,KEK}.cfg</code>
            <p>E vamos editar o par√¢metro <em>Platform Key</em> para <em>Key Exchange Key</em>:</p>
            <code>sed -i 's/Platform Key/Key Exchange Key/g' /keys/cfg/KEK.cfg</code>
            <p>E gerar as chaves agora usando o <em>KEK.cfg</em>:</p>
            <code>openssl req -x509 -sha256 -days 3650 -outform PEM -config keys/cfg/KEK.cfg -keyout keys/KEK.key -out keys/KEK.crt</code>
            <p>Confira com:</p>
            <code>openssl x509 -text -noout -inform PEM -in keys/KEK.crt</code>
            <p>Mesmo esquema para o <em>db.cfg</em>, primeiro copiar o arquivo:</p>
            <code>cp -v keys/cfg/{PK,db}.cfg</code>
            <p>Depois alterar o commonName:</p>
            <code>sed -i 's/Platform Key/Signature Database/g' keys/cfg/db.cfg</code>
            <p>Gerar a chave:</p>
            <code>openssl req -x509 -sha256 -days 3650 -outform PEM -config keys/cfg/db.cfg -keyout keys/db.key -out keys/db.crt</code>
            <p>E depois verificar a chave:</p>
            <code>openssl x509 -text -noout -inform PEM -in keys/db.crt</code>
        </details>
        <h2>Por que n√£o estamos criando chaves DBX?</h2>
        <p>Pelo fato de DBX ser uma lista de revoga√ß√£o de hashes sabidamente maliciosos, expirados ou revogados, o interessante √© adicionar o m√°ximo de assinaturas revogadas poss√≠vel, de prefer√™ncia extendendo as chaves que j√° vieram na sua placa m√£e com listas de revoga√ß√µes mais novas, jamais tenha uma chave DBX nova.</p>
        <!-- M√âTODO AVAN√áADO - GERAR UUID -->
        <!-- ///////////////////////////////////////////////////////////////////////////////////////////////-->
        <h2>Converter para formato AUTH</h2>
        <p>Agora com as chaves devidamente criadas precisamos gerar um identificador √∫nico para converter os certificados para o formato <em>AUTH</em> , para isso use o comando:</p>
        <!--
        <code>uuidgen > uuid.txt</code>
        -->
        <code>echo "$(uuidgen -r)" > keys/uuid.txt</code>
        <p>Para verificar o c√≥digo gerado use o comando:</p>
        <code>cat keys/uuid.txt</code>
        <p>Vai retornar uma como a do exemplo abaixo:</p>
        <code>XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX</code>
        <!-- GERANDO OS ARQUIVOS ESL -->
        <!-- ///////////////////////////////////////////////////////////////////////////////////////////////-->
        <h3>Gerando os arquivos ESL</h3>
        <p>O arquivo <em>.esl</em> (EFI Signature List) √© o arquivo usado no EFI para gerar lista de assinatura de bin√°rios confi√°veis, para gerar os .esl use o comando:</p>
        <code>for key_type in PK KEK db; do cert-to-efi-sig-list -g $(< keys/uuid.txt) keys/${key_type}.crt keys/esl/${key_type}.esl; done</code>
        <p>Caso queira gerar manualmente:</p>
        <code>cert-to-efi-sig-list -g "$(< keys/uuid.txt)" keys/PK.crt keys/esl/PK.esl</code>
        <code>cert-to-efi-sig-list -g "$(< keys/uuid.txt)" keys/KEK.crt keys/esl/KEK.esl</code>
        <code>cert-to-efi-sig-list -g "$(< keys/uuid.txt)" keys/db.crt keys/esl/db.esl</code>
        <p>(opcional) Gerando noPK esl:</p>
        <code>touch keys/esl/noPK.esl</code>
        <!-- GERANDO OS ARQUIVOS AUTH -->
        <!-- ///////////////////////////////////////////////////////////////////////////////////////////////-->
        <h3>Gerando os arquivos AUTH</h3>
        <p>O arquivo <em>.auth</em> √© o arquivo usado no EFI para atalizar ou modificar as chaves de Secure Boot, observe que existe uma ordem para ger√°-lo, primeiro usamos a chave PK privada com o PK ESL para gerar o PK AUTH:</p>
        <code>sign-efi-sig-list -g "$(< keys/uuid.txt)" -t "$(date +'%F %T')" -c keys/PK.crt -k keys/PK.key PK keys/esl/PK.esl keys/auth/PK.auth</code>
        <p>Depois usamos a chave privada PK com o certificado PK para gerar o KEK AUTH:</p>
        <code>sign-efi-sig-list -g "$(< keys/uuid.txt)" -t "$(date +'%F %T')" -c keys/PK.crt -k keys/PK.key KEK keys/esl/KEK.esl keys/auth/KEK.auth</code>
        <p>Por fim usamos a chave privada KEK com o certificado KEK para gerar o DB AUTH:</p>
        <code>sign-efi-sig-list -g "$(< keys/uuid.txt)" -t "$(date +'%F %T')" -c keys/KEK.crt -k keys/KEK.key db keys/esl/db.esl keys/auth/db.auth</code> 
        <p>(opcional) Gerando noPK AUTH (reset key):</p>
        <code>sign-efi-sig-list -g "$(< keys/uuid.txt)" -t "$(date +'%F %T')" -c keys/PK.crt -k keys/PK.key PK keys/esl/noPK.esl keys/auth/noPK.auth</code>  
        <!-- INSTALANDO AS CHAVES -->
        <!-- ///////////////////////////////////////////////////////////////////////////////////////////////-->
        <h2>Instalando as chaves (presumindo que voc√™ est√° em Setup Mode)</h2>
        <code>sudo efi-updatevar -f keys/auth/dbx.auth dbx</code>
        <code>sudo efi-updatevar -f keys/auth/db.auth db</code>
        <code>sudo efi-updatevar -f keys/auth/KEK.auth KEK</code>
        <code>sudo efi-updatevar -f keys/auth/PK.auth PK</code>
        <p>A execu√ß√£o bem-sucedida desse comando em <em>Windows mode</em> finaliza o <em>Setup mode</em> e deixa o Secure Boot em <em>User mode</em>.</p>
        <p>Para verificar se as chaves foram devidamente incorporadas voc√™ pode usar o comando:</p>
        <code>efi-readvar</code>
        <p>Ou, para verificar de maneira independente:</p>
        <code>efi-readvar -v PK</code>
        <code>efi-readvar -v KEK</code>
        <code>efi-readvar -v db</code>
        <code>efi-readvar -v dbx</code>
        <!-- ASSINAR OS M√ìDULOS -->
        <!-- ///////////////////////////////////////////////////////////////////////////////////////////////-->
        <h2>Como assinar m√≥dulos?</h2>
        <p>Aqui √© um exemplo de como assinar o Kernel usando as chaves <em>db</em>:</p>
        <code>sbsign --key keys/db.key --cert keys/db.crt --output /boot/vmlinuz.signed /boot/vmlinuz</code>
        <p>Para verificar a assinatura no execut√°vel use o comando:</p>
        <code>sbverify --list /boot/vmlinuz.signed</code>
        <h2>Gerando <em>HOOK</em> de assinatura</h2>
        <p>Para n√£o ter que ficar assinando o kernel manualmente, √© interessante criar um <i>HOOK</i> no pacman para que sempre que o pacote <em>linux</em> ou <em>linux-lts</em> for instalado ou atualizado ele vai ser assinado automaticamente, comece criando o arquivo de HOOK em <mark>/etc/pacman.d/hooks/sbsign-linux.hook</mark> com o conte√∫do:</p>
<pre><code>
[Trigger]
Operation = Upgrade
Type = Package
Target = linux
    
[Action]
Description = Assinar o Kernel Linux para Secure Boot
When = PostTransaction
Exec = /usr/bin/sbsign \
 --key <em>caminho_da_db.key</em> \
 --cert <em>caminho_da_db.crt</em> \
 --output /boot/vmlinuz-linux /boot/vmlinuz-linux
</code></pre>
        <p>Entendeu n√©? Caso voc√™ tamb√©m use o kernel LTS crie o arquivo <mark>/etc/pacman.d/hooks/sbsign-linux-lts.hook</mark> com o conte√∫do:</p>
<pre><code>
[Trigger]
Operation = Upgrade
Type = Package
Target = linux-lts
                
[Action]
Description = Assinar o Kernel Linux LTS para Secure Boot
When = PostTransaction
Exec = /usr/bin/sbsign \
--key <em>caminho_da_db.key</em> \
--cert <em>caminho_da_db.crt</em> \
--output /boot/vmlinuz-linux-lts /boot/vmlinuz-linux-lts
</code></pre>
        <p>Lembrando que voc√™ pode fazer esse <em>HOOK</em> para qualquer outro pacote, inclusive usando essa mesma estrutura voc√™ pode assinar seus bootloaders e at√© mesmo pode usar esse gatilho para gerar automaticamente seus presets de UKI usando o comando:</p>
        <code>Exec = /usr/bin/mkinitcpio -p linux-uki</code>
        <h3>E isso funciona para qualquer bootloader?</h3>
        <p>Sim... E n√£o...</p>
        <p>Perceba: Existe uma diferen√ßa entre uma aplica√ß√£o ser assinada para funcionar em Secure Boot e uma aplica√ß√£o funcionar junto com o Secure Boot. No sentido de que existem maneiras de iniciar o sistema sem problema algum com o Secure Boot ativado, por√©m esses mecanismos n√£o v√£o manter a cadeia de confian√ßa. Um exemplo desses mecanismos √© o <em>EFISTUB</em>, se voc√™ (assim como eu) gosta de fazer uso de EFISTUB voc√™ vai poder iniciar o seu sistema sem grandes problemas com o Secure Boot ativo por√©m (ao menos at√© a presente data) o EFISTUB n√£o √© capaz de fazer a ger√™ncia dessa cadeia de seguran√ßa. Salvo engano, a maneira mais enxuta de ter um sistema Linux compat√≠vel com Secure Boot √© o uso de <em>Unified Kernel Images</em> ( ou <em>UKI's</em>), salvo engano o Clover, o GRUB, o rEFInd, systemd-boot tamb√©m s√£o compat√≠veis.</p>
        <!-- GERANDO UKI's -->
        <!-- ///////////////////////////////////////////////////////////////////////////////////////////////-->
        <h3>E como gerar Unified Kernel Images?</h3>
        <p>Olha... Existem in√∫meras maneiras de se fazer isso, desde concatenar manualmente do microcode at√© o initrd (que nem ferrando que eu vou explicar aqui üòÇ), at√© usar o mkinitcpio para fazer. Vamos come√ßar duplicando o preset do arquivo <em>/etc/mkinitcpio.d/linux.preset</em> <strong>ou</strong> <em>/etc/mkinitcpio.d/linux-lts.preset</em> (caso voc√™ prefira usar o kernel LTS para o seu UKI):</p>
        <code>sudo cd /etc/mkinitcpio.d/linux.preset /etc/mkinitcpio.d/linux-uki.preset</code>
        <p><strong>OU</strong></p>
        <code>sudo cd /etc/mkinitcpio.d/linux-lts.preset /etc/mkinitcpio.d/linux-lts-uki.preset</code>
        <p>Edite o rec√©m criado, seja ele o <em>linux-uki.preset</em> ou o <em>linux-lts-uki.preset</em>, o seu arquivo deve estar mais ou menos assim:</p>
<pre><code>
# mkinitcpio preset file for the 'linux' package

#ALL_config="/etc/mkinitcpio.conf"
ALL_kver="/boot/vmlinuz-linux"
    
PRESETS=('default' 'fallback')
    
#default_config="/etc/mkinitcpio.conf"
default_image="/boot/initramfs-linux.img"
#default_uki="/efi/EFI/Linux/arch-linux.efi"
#default_options="--splash /usr/share/systemd/bootctl/splash-arch.bmp"
    
#fallback_config="/etc/mkinitcpio.conf"
fallback_image="/boot/initramfs-linux-fallback.img"
#fallback_uki="/efi/EFI/Linux/arch-linux-fallback.efi"
fallback_options="-S autodetect"
</code></pre>
        <p>Vamos entender essas linhas:</p>
        <ul>
            <li><p><em>#ALL_config</em> indica explicitamente qual arquivo de configura√ß√£o base deve ser usado para todos os presets dentro desse arquivo, considerando que o arquivo padr√£o ser√° usado ent√£o n√£o faz diferen√ßa descomentar essa linha agora;</p></li>
            <li><p><em>ALL_kver</em> indica o caminho de kernel que vai ser utilizado, como se trata do preset <em>linux</em> logo o arquivo daqui √© o <em>/boot/vmlinuz-linux</em>, se voc√™ quiser usar outro kernel basta alterar aqui;</p></li>
            <li><p><em>PRESETS</em> indica quais dos presets ser√£o gerados, nesse caso o preset 'default' e 'fallback' est√£o ativos, voc√™ pode remover o fallback caso tenha certeza de manter outro kernel e/ou entrada de reserva (como farei no exemplo abaixo);</p></li>
            <li><p><em>default_config</em> indica a configura√ß√£o base que ser√° utilizada dentro do preset <em>'default'</em> ;</p></li>
            <li><p><em>default_image</em> indica o nome da imagem padr√£o de initrd para ser gerada, nesse caso comentaremos essa linha pois ele estar√° embutido;</p></li>
            <li><p><em>default_uki</em> indica o caminho onde ser√° gerado o UKI padr√£o, descomentaremos essa linha, embora n√£o recomendado voc√™ pode alterar para <mark>/efi/EFI/BOOT/BOOTX64.EFI</mark> para deixar a UKI como loader padr√£o e n√£o ter mais necessidade de cria√ß√£o de entrada de boot;</p></li>
            <li><p><em>default_options</em> indica op√ß√µes para a imagem padr√£o, voc√™ pode descomentar ela para possibilitar o splash mas n√£o use ela para os par√¢metros de kernel;</p></li>
            <li><p>As linhas abaixo contendo <em>fallback_</em> s√£o exatamente a mesma coisa s√≥ que para o preset <em>'fallback'</em> , edite conforme a sua necessidade.</p></li>
        </ul>
        <p>No fim o meu ficar√° assim:</p>
<pre><code>
# mkinitcpio preset file for the 'linux' package
            
#ALL_config="/etc/mkinitcpio.conf"
ALL_kver="/boot/vmlinuz-linux"
                
PRESETS=('default')
                
#default_config="/etc/mkinitcpio.conf"
#default_image="/boot/initramfs-linux.img"
default_uki="/efi/EFI/Linux/arch-linux.efi"
#default_options="--splash /usr/share/systemd/bootctl/splash-arch.bmp"
                
#fallback_config="/etc/mkinitcpio.conf"
fallback_image="/boot/initramfs-linux-fallback.img"
#fallback_uki="/efi/EFI/Linux/arch-linux-fallback.efi"
fallback_options="-S autodetect"
</code></pre>
        <p>Para inserir par√¢metros de kernel para a imagem voc√™ pode usar o diret√≥rio <mark>/etc/cmdline.d/</mark> e criar os arquivo <em>seu_arquivo.conf</em> ou editar diretamente o arquivo <mark>/etc/kernel/cmdline</mark>. Como eu quase sempre uso zswap, vou usar de exemplo a cria√ß√£o de um arquivo de configura√ß√£o de par√¢metro de kernel para ele:</p>
        <code>sudo nvim /etc/cmdline.d/zswap.conf</code>
        <p>Inserir as linhas:</p>
        <code>zswap.enabled=1 zswap.zpool=zsmalloc</code>
        <section class="alert">
            <p>Eu recomendo fortemente voc√™ adicionar o argumento <em>microcode</em> dentro dos <i>HOOKS</i> do <mark>/etc/mkinitcpio.conf</mark> <strong>antes</strong> de gerar o UKI!</p>
        </section>
        <p>E por fim vou gerar a UKI do preset linux com o comando:</p>
        <code>mkinitcpio -p linux-uki</code>
        <p>Se voc√™ fez tudo corretamente, vai ver tanto a linha indicando o uso do <em>cmdline</em> quando a mensagem de sucesso na gera√ß√£o do UKI:</p>
        <code>-> Using cmdline file: '/etc/cmdline.d/zswap.conf'<br>==> Unified kernel image generation successful</code>
        <!-- HOOK ASSINATURA UKI -->
        <!-- ///////////////////////////////////////////////////////////////////////////////////////////////-->
        <h2>HOOK de assinatura da Unified Kernel Image (UKI)</h2>
        <!--
        <p><mark>/etc/initcpio/post/kernel-sbsign</mark> com o conte√∫do:</p>
<code><pre>
#!/usr/bin/env bash

kernel="$1"
[[ -n "$kernel" ]] || exit 0
    
# use already installed kernel if it exists
[[ ! -f "$KERNELDESTINATION" ]] || kernel="$KERNELDESTINATION"
    
keypairs=(<em>'caminho_para_db.key'</em> <em>'caminho_para_db.crt'</em>)
    
for (( i=0; i<${#keypairs[@]}; i+=2 )); do
    key="${keypairs[$i]}" cert="${keypairs[(( i + 1 ))]}"
    if ! sbverify --cert "$cert" "$kernel" &>/dev/null; then
        sbsign --key "$key" --cert "$cert" --output "$kernel" "$kernel"
    fi
done
</pre></code>
        <p>Ap√≥s editar o caminho para as chaves e salvar o arquivo, deixe ele execut√°vel com o comando:</p>
        <code>sudo chmod+x /etc/initcpio/post/kernel-sbsign</code>
        <p>Assim, toda vez que </p>
        -->
        <p>Uma vez que a UKI j√° est√° gerada e assinada, basta definir a sua entrada para o bootloader, para o meu caso vou usar de exemplo o carregamento direto da UKI desde a UEFI usando o <em>efibootmgr</em>:</p>
        <code>sudo efibootmgr --create --disk /dev/<em>storageA</em>  --part <em>P2</em> --label "Arch Linux UKI" --loader '\EFI\Linux\arch-linux.efi' --unicode --verbose</code>
        <h2>Retornando para Setup Mode</h2>
        <code>sudo efi-updatevar -f keys/auth/noPK.auth PK</code>
        <p>Como foi dito acima a execu√ß√£o bem-sucedida desse comando efetivamente apaga o conte√∫do da PK, desativando assim o Secure Boot.</p>
        <!--
        Como apagar as chaves?
        -->
        <!-- COMBINANDO AS CHAVES -->
        <!-- ///////////////////////////////////////////////////////////////////////////////////////////////-->
        <h2>Combinando as chaves</h2>
        <p><i>"Ah, mas voc√™ disse que existia a possibilidade de brickar a m√°quina sem as chaves Windows, n√£o existe nenhuma maneira de mitigar isso?"</i></p>
        <p>Tem sim e na verdade √© bem simples... Basta combinar as chaves.</p>
        <p>√â s√©rio. Exemplo:</p>
        <code>cat keys/backup/old_db.esl keys/esl/db.esl > combined_db.esl</code>
        <p>Obviamente, fora a chave PK que √© √∫nica voc√™ pode fazer isso com todas as listas de chaves, mas <strong>lembre-se depois de assinar todas as outras chaves na mesma ordem que o exemplo acima!</strong>.</p>
        <!--
        
        bootctl status --no-pager

        pesign -S -i /boot/efi/EFI/fedora/shimx64.efi

        sbctl

        -->
        <h2>T√°... Mas e quanto ao TPM?</h2>
        <p>Bom, lidar com o m√≥dulo TPM √© bem mais tranquilo, e embora ele seja um adjacente do entendimento do UEFI e do Secure Boot, a documenta√ß√£o a respeito do TPM √© bem menos obtusa vamos entender algumas coisinhas antes de come√ßar colocar a m√£o na massa...</p>
        <h3>TPM1.2 e TPM2.0</h3>
        <p>Quando se fala em TPM, o TPM2.0 √© apresentado como o √∫nico na face da terra, e o TPM1.2 como uma tecnologia distinta e morta... E n√£o est√° t√£o errado n√£o.</p>
        <p>A grande verdade √© que o TPM1.2 era um m√≥dulo adicional em seu lan√ßamento, basicamente n√£o teve suporte em sua vida √∫til, e acabou por ter suas medidas de seguran√ßa superadas antes de sua ado√ß√£o. Quando o TPM1.2 teve seu suporte pedido no <em>systemd-cryptenroll</em>, Lennart Poettering responde tratando o TPM1.2 como uma tecnologia distinta e obsoleta... E seja l√° qual opini√£o voc√™ tenha do Lennart, ele est√° completamente certo nisso.</p>
        <p>Eu n√£o vou dizer que o TPM1.2 √© uma tecnologia in√∫til, longe disso, ele continua sendo bastante funcional, o ponto √© que quando voc√™ pensar em TPM1.2 e TPM2.0, n√£o pense em um versionamento linear e uma melhoria tecnol√≥gica como de <i>Resident Evil 1</i> para <i>Resident Evil 2</i>, pense em uma mudan√ßa dr√°stica e de g√™nero completamente distinto, algo como de <i>Dino Crisis 2</i> para <i>Dino Crisis 3</i>... E se voc√™ j√° jogou essas franquias entende perfeitamente o que estou dizendo.</p>
        <p>Ent√£o, para que n√£o seja subentendido: TPM1.2 e TPM2.0 s√£o dispositivos equivalentes sim, por√©m de tecnologia completamente distinta, ok? Ent√£o, a menos que daqui pra baixo tenha algo espec√≠fico para o TPM1.2 (e sim, ter√°) considere que estou lidando com o TPM2.0, ok? Ok!</p>
        <h3>As sementes (<i>seeds</i>) e as chaves internas (<i>keys</i>)</h3>
        <p>O TPM trabalha basicamente com 3 </p>
        <h3>PCR</h3>
        <p><em>Platform Configuration Registers</em> (ou <em>PCR</em>), s√£o basicamente registradores que podem guardar (e selar) vers√µes de software ou estado de m√°quina atrav√©s de hashes.</p>
        <table>
            <tr>
                <th>PCR</th>
                <th>Descri√ß√£o</th>
                <th>Extendido por</th>
            </tr>
            <tr><td>PCR0</td><td>C√≥digo execut√°vel do firmware do sistema principal (Firmware). Pode mudar se voc√™ atualizar seu UEFI.</td><td>Firmware</td></tr>
            <tr><td>PCR1</td><td>Dados do firmware do sistema principal (configura√ß√µes do UEFI).</td><td>Firmware</td></tr>
            <tr><td>PCR2</td><td>C√≥digo execut√°vel estendido ou conect√°vel (OpROMs).</td><td>Firmware</td></tr>
            <tr><td>PCR3</td><td>Dados do firmware estendidos ou conect√°veis. Definido durante a fase de sele√ß√£o do dispositivo de inicializa√ß√£o do UEFI.</td><td>Firmware</td></tr>
            <tr><td>PCR4</td><td>C√≥digo do Gerenciador de Inicializa√ß√£o e Tentativas de Inicializa√ß√£o. Mede o gerenciador de inicializa√ß√£o e os dispositivos que o firmware tentou inicializar.</td><td>Firmware</td></tr>
            <tr><td>PCR5</td><td>Configura√ß√£o e dados do Gerenciador de Inicializa√ß√£o. Pode medir a configura√ß√£o de carregadores de inicializa√ß√£o; inclui a tabela de parti√ß√£o GPT.</td><td>Firmware</td></tr>
            <tr><td>PCR6</td><td>Eventos de retomada dos estados de energia S4 e S5.</td><td>Firmware</td></tr>
            <tr><td>PCR7</td><td>Estado de Secure Boot. Cont√©m o conte√∫do completo de PK/KEK/db, bem como os certificados espec√≠ficos usados para validar cada aplicativo de inicializa√ß√£o.</td><td>Firmware, shim (adiciona MokList, MokListX e MokSBState)</td></tr>
            <tr><td>PCR81</td><td>Hash da linha de comando do kernel.</td><td>GRUB</td></tr>
            <tr><td>PCR91</td><td>Hash do initrd e das op√ß√µes de carregamento EFI.</td><td>Linux (mede initrd e op√ß√µes EFI, essencialmente os par√¢metros do kernel)</td></tr>
            <tr><td>PCR101</td><td>Reservado para uso futuro.</td><td></td></tr>
            <tr><td>PCR111</td><td>Hash da imagem unificada do kernel.</td><td>systemd-stub(7)</td></tr>
            <tr><td>PCR121</td><td>Linha de comando do kernel substitu√≠da, credenciais.</td><td>systemd-stub(7)</td></tr>
            <tr><td>PCR131</td><td>Extens√µes do sistema.</td><td>systemd-stub(7)</td></tr>
            <tr><td>PCR141</td><td>MokList, MokListX e MokSBState do shim.</td><td>shim</td></tr>
            <tr><td>PCR151</td><td>Hash da chave de volume LUKS.</td><td>systemd-cryptsetup</td></tr>
            <tr><td>PCR161</td><td>Depura√ß√£o. Pode ser usada e redefinida a qualquer momento. Pode estar ausente em uma vers√£o oficial do firmware.</td><td></td></tr>
            <tr><td>PCR23</td><td>Suporte a aplicativos. O sistema operacional pode definir e redefinir esse PCR.</td><td></td></tr>
        </table>
        <p>Podemos implementar essas fun√ß√µes para automatizar a seguran√ßa em certas tarefas, como por exemplo...</p>
        <h3>Desbloqueando um disco com o TPM 2.0</h3>
        <p>Vamos supor que voc√™ seguiu o meu tutorial de instala√ß√£o do Archlinux e para criar um pendrive encriptado em <em>/dev/storageAP4</em>, seja usando um arquivo de chave ou uma senha simples, mas agora quer que o m√≥dulo TPM fa√ßa todo o trabalho sozinho e desbloqueie isso automaticamente por√©m <strong>se e somente se</strong> o estado da m√°quina n√£o foi alterado. A primeira coisa que voc√™ precisa fazer √© abrir o dispositivo com o LUKS. Vou usar de exemplo o comando abaixo:</p>
        <code>cryptsetup luksOpen <em>/dev/storageAP4</em> <em>cryptroot</em></code>
        <p>Agora, verifique a exist√™ncia de dispositivos TPM 2.0 v√°lidos:</p>
        <code>systemd-cryptenroll --tpm2-device=list</code>
        <p>Caso <strong>n√£o seja encontrado</strong> nenhum m√≥dulo TPM 2.0 o comando retornar√°:</p>
        <code>No suitable TPM2 devices found.</code>
        <p><strong>*</strong> Lembrando que no Arch √© necess√°rio a instala√ß√£o do pacote <em>tpm2-tss</em>, os <i>HOOKS</i> <em>systemd</em> e <em>sd-encrypt</em> para mkinitcpio e o m√≥dulo <em>tpm2-tss</em> para Dracut.</p>
        <p>Mas ok, vamos supor que o TPM2.0 foi encontrado, o volume encriptado est√° acess√≠vel e agora queremos fazer com que uma chave seja criada e armazenada no TPM2.0, essa mesma chave seja gravada num dos slots de senha do LUKS no disco, e criar um v√≠nculo entre a libera√ß√£o da chave e ao estado do PCR 7 do TPM, para isso use o comando abaixo:</p>
        <code>systemd-cryptenroll --tpm2-device=<em>caminho_do_seu_tpm2.0</em> --tpm2-pcrs=7 <em>/dev/storageAP4</em></code>
        <p>Voc√™ pode usar o dispositivo <em>/dev/gpt-auto-root-luks</em> para apontar para a parti√ß√£o raiz criptografada antes do desbloqueio (que eu n√£o recomendo), pode usar <em>tpm2-device=auto</em> para n√£o ter que especificar manualmente o dispotivo, e por fim lembre-se que caso v√° usar o endere√ßo, <em>/dev/storageAP4</em> se trata do endere√ßo real do dispotivo e n√£o do endere√ßo em <em>/dev/mapper</em>! Voc√™ tamb√©m pode atrelar a mais estados PCR, vamos supor que voc√™ queira atrelar n√£o s√≥ ao estado de secure boot (PCR7) como tamb√©m ao estado do firmware (PCR0), nesse caso voc√™ pode usar o argumento <em>tpm2-pcrs=0+7</em>.</p>
        <p>Algumas pessoas preferem criptografar o disco com uma senha simples, depois usar o comando:</p>
        <code>systemd-cryptenroll /dev/<em>/dev/storageAP4</em> --recovery-key</code>
        <p>Para gerar uma senha de recupera√ß√£o, salvar em algum local seguro e por √∫ltimo:</p>
        <code>systemd-cryptenroll /dev/<luks-volume> --wipe-slot=password</code>
        <p>Para limpar o slot de senha... Eu acho idiota pelo fato de que se voc√™ usa algum recurso para guardar a chave de recupera√ß√£o com seguran√ßa, voc√™ pode fazer o mesmo com a senha de encripta√ß√£o mas a√≠ vai de cada um.</p>
        <h3>Funcionamento Interno do TPM 2.0 - Hierarquias</h3>
        <p>Entenda cada hierarquia como um cofre, cada hierarquia tem um nome, uma <i>seed</i> (semente), uma <i>root key</i> (chave raiz) e um namespace associado a ela. </p>
        <h4>Endorsement Hierarchy</h4>
        <p>A Endorsement Hierarchy tem como seed a <em>Endorsement Primary Seed (EPS)</em> e como chave prim√°ria a <em>Endorsement Key (EK)</em>. Ambas s√£o normalmente geradas na f√°brica, com a EPS sendo permanente e imut√°vel, e a EK derivada dela de forma determin√≠stica ou pr√©-gerada e armazenada com um certificado X.509. Essa hierarquia est√° sob controle exclusivo do fabricante do TPM. √â usada para atestar a legitimidade do m√≥dulo TPM (em processos de remote attestation) e para gerar chaves vinculadas exclusivamente a esse TPM f√≠sico.</p>
        <h4>Platform Hierarchy</h4>
        <p>A Platform Hierarchy tem como seed a <em>Platform Primary Seed (PPS)</em> e como chave prim√°ria a <em>Platform Primary Key (PPK)</em>. Ambas s√£o geradas internamente pelo TPM durante o provisionamento inicial ou no primeiro uso, e geralmente est√£o sob controle exclusivo do firmware ou BIOS, acess√≠vel via <mark>platformAuth</mark> . Essa hierarquia √© usada para verificar a integridade do boot (via PCRs, Secure Boot, Measured Boot) e selar chaves que s√≥ podem ser acessadas em ambientes de inicializa√ß√£o leg√≠tima.</p>
        <h4>Storage Hierarchy</h4>
        <p>A Storage Hierarchy tem como seed a <em>Storage Primary Seed (SPS)</em> e como chave prim√°ria a <em>Storage Root Key (SRK)</em>. S√£o geradas pelo TPM no provisionamento inicial ou no primeiro uso, e est√£o sob controle do usu√°rio ou sistema operacional, via <mark>ownerAuth</mark>. Essa hierarquia √© usada para armazenar, embrulhar (wrap) e selar (seal) dados criptogr√°ficos sob pol√≠ticas definidas (como PCRs, senhas, etc.), e serve como raiz para a cria√ß√£o de todos os objetos protegidos no TPM ‚Äî incluindo chaves, dados criptografados e assinaturas digitais.</p>
        <h3>E quanto ao TPM 1.2?</h3>
        <p>Ele n√£o tem seeds, nem m√∫ltiplas hierarquias, nem cria√ß√£o de chaves prim√°rias sob demanda, embora ele tamb√©m tenha uma <em>Endorsement Key (EK)</em> de f√°brica e uma <em>Storage Root Key (SRK)</em> possa ser criada no provisionamento do m√≥dulo tudo gira em torno dessas chaves e ele tem a cria√ß√£o de pol√≠ticas basicamente limitadas aos PCRs. Como no exemplo abaixo:</p>
<code><pre>
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó                    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë    TPM 1.2       ‚ïë                    ‚ïë            TPM 2.0             ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù                    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    [F√°brica]                                       [F√°brica]
Endorsement Key (EK)                        Endorsement Primary Seed (EPS)
        ‚îÇ                                               ‚îÇ
        ‚ñº                                               ‚ñº
[TakeOwnership Executado]                   Deriva Endorsement Key (EK)
        ‚îÇ                                               ‚îÇ
        ‚ñº                                               ‚ñº
Gera Storage Root Key (SRK)             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                               ‚ñº               ‚ñº                 ‚ñº
        ‚îÇ                         Platform Seed   Storage Seed      (Endorsement)
        ‚îÇ                              (PPS)          (SPS)             (EPS)
        ‚ñº                               ‚îÇ               ‚îÇ                 ‚îÇ
Todas as chaves                         ‚ñº               ‚ñº                 ‚ñº
s√£o criadas sob:                Platform Primary   Storage Root     Endorsement Key
Storage Root Key (SRK)              Key (PPK)          Key (SRK)         (EK)
        ‚îÇ                               ‚îÇ               ‚îÇ
        ‚ñº                               ‚ñº               ‚ñº
Seal com SRK                      Wrap com PPK    Wrap com SRK     Assinatura / Attestation
Wrap com SRK                      Seal com PPK    Seal com SRK     com chave ligada ao TPM
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Limitado a PCRs   e pol√≠ticas       e pol√≠ticas         (EK, AK, etc)
        ‚îÇ                       (PCRs, PIN, etc)  (PCRs, PIN, etc)
        ‚ñº
[Uso condicionado a PCRs]
</pre></code>
        <!--
        <h2>O que √© Wrap e Seal?</h2>
        <h3>Wrap (embrulhar)</h3>
        <p>√â o processo de criptografar um objeto (ex: chave ou blob de dados) com uma chave-pai dentro do TPM. Serve para proteger e vincular hierarquicamente esse objeto a outro.</p>
        <ul>
            <li><p>‚úÖ Protege por chave criptogr√°fica</p></li>
            <li><p>‚úÖ Impede uso fora da hierarquia</p></li>
            <li><p>‚ùå N√£o depende diretamente de PCRs</p></li>
        </ul>
        <h3>Seal (selar)</h3>
        <p>√â o processo de associar dados ou chaves a uma condi√ß√£o de uso, como um estado espec√≠fico de PCRs, PINs, ou comandos.Voc√™ pode selar dados para que s√≥ sejam acess√≠veis em determinado boot estado, por exemplo.</p>
        <ul>
            <li><p>‚úÖ Protege por condi√ß√£o/pol√≠tica (ex: PCRs)</p></li>
            <li><p>‚ùå N√£o implica necessariamente em v√≠nculo a chave-pai</p></li>
            <li><p>Pode envolver wrapping como parte interna</p></li>
        </ul>
<code><pre>
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó           ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë      WRAP          ‚ïë           ‚ïë        SEAL          ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù           ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù    
        ‚ñº                                   ‚ñº
[Dado ou chave a proteger]       [Dado sens√≠vel (ex: senha)]
        ‚îÇ                                   ‚îÇ
        ‚ñº                                   ‚ñº
[Seleciona chave-pai]            [Define pol√≠tica (PCRs, etc)]
        ‚îÇ                                   ‚îÇ
        ‚ñº                                   ‚ñº
[Criptografa com chave-pai]      [Gera objeto de pol√≠tica]
        ‚îÇ                                   ‚îÇ
        ‚ñº                                   ‚ñº
WRAPPED OBJECT                   SELA DADOS COM POL√çTICA
        ‚îÇ                                   ‚îÇ
        ‚ñº                                   ‚ñº
[Armazena blob no disco]         [Armazena blob no disco]
        ‚îÇ                                   ‚îÇ
        ‚ñº                                   ‚ñº
Para usar no futuro:                Para usar no futuro:
        ‚ñº                                   ‚ñº
[Recarrega chave-pai]           [Verifica pol√≠tica (PCRs, PIN...)]
[Descriptografa objeto]         [Se pol√≠tica = ok ‚Üí libera dado]    
</pre></code>
        -->

    </main>
    <footer id="main-footer">
        <p>Est√° p√°gina ainda est√° em constru√ß√£o üöß</p>
        <a class="footerlink" href="#main-header">‚Üë Retornar ao topo ‚Üë</a>
    </footer>
</body>
</html>